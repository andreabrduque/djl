/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package hybrid.engine.bug;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.List;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import ai.djl.MalformedModelException;
import ai.djl.ModelException;
import ai.djl.inference.Predictor;
import ai.djl.ndarray.NDArray;
import ai.djl.ndarray.NDArrays;
import ai.djl.ndarray.NDList;
import ai.djl.ndarray.NDManager;
import ai.djl.repository.zoo.Criteria;
import ai.djl.repository.zoo.ModelNotFoundException;
import ai.djl.repository.zoo.ZooModel;
import ai.djl.repository.zoo.ModelZoo;
import ai.djl.training.util.ProgressBar;
import ai.djl.translate.NoBatchifyTranslator;
import ai.djl.translate.TranslateException;
import ai.djl.translate.TranslatorContext;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.time.Duration;
import ai.djl.ndarray.index.NDIndex;
import ai.djl.Device;


public class App {

    private static final Logger logger = LoggerFactory.getLogger(App.class);

    private App() {}

    private final static class EmptyClassification {}

    private final static class Batch {
        long[][] batch;

        Batch() {
            this.batch = this.generateBatch();
        }

        private long[][] generateBatch() {
            long[] inputs = LongStream.rangeClosed(1, 256).map(j -> 1L).toArray();         
            return LongStream.rangeClosed(0, 99)
                  .mapToObj(i -> inputs)
                  .toArray(long[][]::new);
        }

        public long[][] getBatch() {
            return batch;
        }
    }    

      private static final class MyTranslator
            implements NoBatchifyTranslator<Batch, EmptyClassification> {
    
        @Override
        public NDList processInput(TranslatorContext ctx, Batch inputs) {
            NDManager inputManager = ctx.getNDManager();
            NDList inputList = new NDList();
            inputList.add(inputManager.create(inputs.getBatch()));
            inputList.add(inputManager.create(inputs.getBatch()));
            inputList.add(inputManager.create(inputs.getBatch()));           
            return inputList;
        }

    
        @Override
        public EmptyClassification processOutput(TranslatorContext ctx, NDList list) {
            NDArray candidates = list.get(1);

            //operation from alternative engine here
            //if I don't do unsupported operations, I don't have any problems
            NDArray batchIds = candidates.get(new NDIndex(":, 0"));

            return new EmptyClassification();
        }
    }

    public static void main(String[] args) throws IOException, TranslateException, ModelException, InterruptedException {
        System.setProperty("ai.djl.pytorch.num_interop_threads", "1");
        System.setProperty("ai.djl.pytorch.num_threads", "1");
        
        String modelUrl = "file:///Users/andreaduque/Workspace/djl/ner_mock.onnx";
        Batch inputs =  new Batch();

        Criteria<Batch, EmptyClassification> criteria =
        Criteria.builder()
                .setTypes(Batch.class, EmptyClassification.class)
                .optModelUrls(modelUrl)
                .optTranslator(new MyTranslator())
                .optEngine("OnnxRuntime")
                .optProgress(new ProgressBar())
                .optOption("intraOpNumThreads", "1")
                .optOption("executionMode", "SEQUENTIAL")
                .optOption("memoryPatternOptimization", "false")
                .optDevice(Device.gpu())
                .build();

        ZooModel<Batch, EmptyClassification> model = ModelZoo.loadModel(criteria);
        
        Duration duration = Duration.ofSeconds(500);
        Boolean loop = true;
        long begin = System.currentTimeMillis();
        while(!duration.isNegative() && loop) {
            try (Predictor<Batch, EmptyClassification> predictor = model.newPredictor()) {                    
                    EmptyClassification result = predictor.predict(inputs);
                    logger.info("prediction");                    
            } catch(Exception e) {
                loop = false;
                e.printStackTrace();
                logger.info("the end");
            }        
            long delta = System.currentTimeMillis() - begin;
            duration = duration.minus(Duration.ofMillis(delta));
            if (!duration.isNegative()) {
                logger.info(duration + " seconds left");
            }
        } 
        model.close();       
    }
}
