/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package hybrid.engine.bug;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.List;
import java.util.stream.LongStream;
import java.util.stream.Collectors;
import ai.djl.MalformedModelException;
import ai.djl.ModelException;
import ai.djl.inference.Predictor;
import ai.djl.modality.Classifications;
import ai.djl.modality.nlp.DefaultVocabulary;
import ai.djl.modality.nlp.bert.BertFullTokenizer;
import ai.djl.ndarray.NDArray;
import ai.djl.ndarray.NDArrays;
import ai.djl.ndarray.NDList;
import ai.djl.ndarray.NDManager;
import ai.djl.repository.zoo.Criteria;
import ai.djl.repository.zoo.ModelNotFoundException;
import ai.djl.repository.zoo.ZooModel;
import ai.djl.training.util.ProgressBar;
import ai.djl.translate.NoBatchifyTranslator;
import ai.djl.translate.TranslateException;
import ai.djl.translate.TranslatorContext;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class App {

    private static final Logger logger = LoggerFactory.getLogger(App.class);

    private App() {}

    public String getGreeting() {
        return "Hello World!";
    }

    private final static class EmptyClassification {}

    private final static class Batch {
        long[][] batch;

        Batch() {
            this.batch = this.generateBatch();
        }

        private long[][] generateBatch() {
            long[] inputs = LongStream.rangeClosed(1, 256).map(j -> 1L).toArray();         
            return LongStream.rangeClosed(0, 99)
                  .mapToObj(i -> inputs)
                  .toArray(long[][]::new);
        }

        public long[][] getBatch() {
            return batch;
        }
    }    

      private static final class MyTranslator
            implements NoBatchifyTranslator<Batch, EmptyClassification> {
    
        @Override
        public NDList processInput(TranslatorContext ctx, Batch inputs) {
            NDManager inputManager = ctx.getNDManager();
            //do non supported operation and watch things explode
            NDList inputList = new NDList();
            inputList.add(inputManager.create(inputs.getBatch()));
            inputList.add(inputManager.create(inputs.getBatch()));
            inputList.add(inputManager.create(inputs.getBatch()));           
            return inputList;
        }

    
        @Override
        public EmptyClassification processOutput(TranslatorContext ctx, NDList list) {
            // NDArray batchOutput = list.singletonOrThrow();
            // int numOutputs = (int) batchOutput.getShape().get(0);
            // Classifications[] output = new Classifications[numOutputs];

            // for (int i = 0; i < numOutputs; i++) {
            //     output[i] = new Classifications(classes, batchOutput.get(i));
            // }
            // return output;
            return new EmptyClassification();
        }
    }

    public static void main(String[] args) throws IOException, TranslateException, ModelException {
        String modelUrl = "file:///Users/andreaduque/Workspace/djl/ner_mock.onnx";
        Batch inputs =  new Batch();

        Criteria<Batch, EmptyClassification> criteria =
        Criteria.builder()
                .setTypes(Batch.class, EmptyClassification.class)
                .optModelUrls(modelUrl)
                .optTranslator(new MyTranslator())
                .optEngine("OnnxRuntime")
                .optProgress(new ProgressBar())
                .optOption("intraOpNumThreads", "1")
                .optOption("executionMode", "SEQUENTIAL")
                .optOption("memoryPatternOptimization", "false")
                .build();

    //     //put a for here
        try (ZooModel<Batch, EmptyClassification> model = criteria.loadModel();
                Predictor<Batch, EmptyClassification> predictor = model.newPredictor()) {
                    EmptyClassification result = predictor.predict(inputs);
        }

       logger.info("the end");
    }
}
